#!/usr/bin/env python3

# Copyright 2016 Endless Mobile, Inc.

import argparse
import collections
import io
import json
import os
import re
import sys
import yaml

"""
For those interested in Autobahn's etymology, it goes roughly like this:
JSON -> Jason Schwartzman -> Shwartz -> Spaceballs -> Radar jammed -> Jam
sandwich -> Cheese sandwich -> Kraft singles -> Kraftwerk -> Autobahn
"""


# This allows you to put a shortdef string (see below) into a slot, instead of
# a module description.
def expand_slot_shorthand(module):
    if isinstance(module, str):
        return {'shortdef': module}
    return module


# This is a shorthand which allows you to specify type and properties in one
# string: 'MyModule{prop: value, prop2: value2}'. The properties part is a YAML
# dictionary. Note that you do have to enclose the string in quotes in YAML,
# because {, }, and : are active characters.
def expand_shortdef(module):
    if ('type' in module or 'properties' in module) and 'shortdef' in module:
        raise ValueError('If you use "shortdef" then you cannot also have '
            '"type" and "properties".')

    shortdef = module.pop('shortdef', None)
    if shortdef is None:
        return module

    match = re.match(r'^([a-zA-Z0-9_.]+)\s*\((.*)\)\s*$', shortdef)
    if match is None:
        module['type'] = shortdef
        return module

    typename, propstring = match.group(1, 2)
    module['properties'] = yaml.load('{' + propstring + '}')
    module['type'] = typename

    return module


def sorted_ordered_dict(regdict):
    sorted_items = sorted(regdict.items(), key=lambda t: t[0])
    return collections.OrderedDict(sorted_items)


def order_module_keys(module):
    retval = collections.OrderedDict({'type': module['type']})
    if 'id' in module:
        retval['id'] = module['id']
    if 'styles' in module:
        retval['styles'] = sorted(module['styles'])
    for key in ('properties', 'slots', 'references'):
        if key in module:
            retval[key] = sorted_ordered_dict(module[key])
    return retval


def walk(module_tree, transform_func):
    # Transform first, in case the transformation adds slots
    module_tree = transform_func(module_tree)
    if 'slots' in module_tree:
        slots = module_tree['slots']
        for slot in slots:
            slots[slot] = walk(slots[slot], transform_func)
    return module_tree


def preprocess(infile):
    tree = yaml.load(infile)['root']
    tree = walk(tree, expand_slot_shorthand)
    tree = walk(tree, expand_shortdef)
    tree = walk(tree, order_module_keys)

    app = collections.OrderedDict((
        ('version', 2),
        ('root', tree),
    ))

    return json.dumps(app, indent=2)


def remove_output(f):
    if f is default_out:
        return
    f.close()
    os.unlink(f.name)

# Ensure stdout is UTF-8
default_out = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Preprocess app.json.')
    parser.add_argument('input', nargs='?', default=sys.stdin,
                        type=argparse.FileType('r'),
                        help='Input file (default: stdin)')
    parser.add_argument('-o', '--output', default=default_out,
                        type=argparse.FileType('w', encoding='utf-8'),
                        help='File to write (default: stdout)')
    args = parser.parse_args()

    try:
        args.output.write(preprocess(args.input))
    except yaml.error.MarkedYAMLError as exc:
        remove_output(args.output)
        sys.stderr.write('Invalid YAML: ' + str(exc) + '\n')
        sys.exit(1)
    except Exception:
        remove_output(args.output)
        raise
    else:
        args.output.write('\n')
